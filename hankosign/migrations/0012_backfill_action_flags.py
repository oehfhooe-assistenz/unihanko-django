# Generated by Django 5.2.5 on 2025-10-31 19:17
# 000Y_backfill_action_flags.py
from django.db import migrations

def backfill(apps, schema_editor):
    Action = apps.get_model('hankosign', 'Action')
    Policy = apps.get_model('hankosign', 'Policy')

    # Map: action_id -> (repeatable_any, sod_any)
    rep = {}
    sod = {}

    # Legacy FK
    for p in Policy.objects.exclude(action__isnull=True)\
            .only('id','is_repeatable','require_distinct_signer','action_id'):
        aid = p.action_id
        rep[aid] = rep.get(aid, False) or bool(getattr(p, 'is_repeatable', False))
        sod[aid] = sod.get(aid, False) or bool(getattr(p, 'require_distinct_signer', False))

    # Legacy M2M
    # We canâ€™t traverse M2M directly in historical apps API nicely; do raw SQL fallback:
    from django.db import connection
    with connection.cursor() as cur:
        cur.execute("""
            SELECT p.is_repeatable, p.require_distinct_signer, pa.action_id
            FROM hankosign_policy_actions pa
            JOIN hankosign_policy p ON p.id = pa.policy_id
        """)
        for is_rep, is_sod, action_id in cur.fetchall():
            rep[action_id] = rep.get(action_id, False) or bool(is_rep)
            sod[action_id] = sod.get(action_id, False) or bool(is_sod)

    for a in Action.objects.all():
        a.is_repeatable = rep.get(a.id, False)
        a.require_distinct_signer = sod.get(a.id, False)
        a.save(update_fields=['is_repeatable','require_distinct_signer'])

def noop_reverse(apps, schema_editor):
    pass

class Migration(migrations.Migration):
    dependencies = [
        ('hankosign', '0011_action_is_repeatable_action_require_distinct_signer_and_more'),
    ]
    operations = [
        migrations.RunPython(backfill, noop_reverse),
    ]
